// user stuff
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username TEXT UNIQUE NOT NULL,
    email TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    role TEXT NOT NULL DEFAULT 'user', -- "user" or "admin"
    created_at TIMESTAMP DEFAULT NOW()
);

use axum::extract::FromRequestParts;
use axum::http::request::Parts;

struct AuthenticatedUser(pub User);

#[async_trait]
impl<S> FromRequestParts<S> for AuthenticatedUser
where
    S: Send + Sync,
{
    type Rejection = ApiError;

    async fn from_request_parts(parts: &mut Parts, _: &S) -> Result<Self, Self::Rejection> {
        let token = parts
            .headers
            .get("Authorization")
            .and_then(|h| h.to_str().ok())
            .ok_or_else(|| ApiError::unauthorized("Missing token"))?;

        let user = decode_jwt(token)?; // your JWT service
        Ok(AuthenticatedUser(user))
    }
}


#[derive(Debug)]
pub struct User {
    pub id: i32,
    pub username: String,
    pub email: String,
    pub password_hash: String,
    pub role: Role,
}

#[derive(Debug, PartialEq, Eq)]
pub enum Role {
    User,
    Admin,
}

impl Role {
    pub fn from_str(s: &str) -> Self {
        match s {
            "admin" => Role::Admin,
            _ => Role::User,
        }
    }
}

// checking permissions in handlers
async fn delete_recipe(
    AuthenticatedUser(user): AuthenticatedUser,
    State(recipe_service): State<Arc<RecipeService>>,
) -> Result<(), ApiError> {
    if user.role != Role::Admin {
        return Err(ApiError::forbidden("Only admins can delete recipes"));
    }

    recipe_service.delete(...).await?;
    Ok(())
}

// sharing recipes
-- Recipe sharing table
CREATE TABLE recipe_shares (
    recipe_id INT NOT NULL REFERENCES recipes(id) ON DELETE CASCADE,
    user_id INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    can_edit BOOLEAN NOT NULL DEFAULT false,
    PRIMARY KEY(recipe_id, user_id)
);

#[derive(Debug)]
pub struct RecipeShare {
    pub user_id: i32,
    pub can_edit: bool,
}

pub struct Recipe {
    pub id: i32,
    pub author_id: i32,
    pub name: String,
    pub description: String,
    pub ingredients: Vec<Ingredient>,
    pub instructions: Vec<Instruction>,
    pub shared_with: Vec<RecipeShare>, // <- this is the key
}

impl Recipe {
    pub fn can_view(&self, user_id: i32) -> bool {
        self.author_id == user_id || self.shared_with.iter().any(|s| s.user_id == user_id)
    }

    pub fn can_edit(&self, user_id: i32) -> bool {
        self.author_id == user_id || self.shared_with.iter().any(|s| s.user_id == user_id && s.can_edit)
    }

    pub fn can_delete(&self, user_id: i32) -> bool {
        self.author_id == user_id
    }
}
